"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6610],{92914:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>r,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var n=i(85893),s=i(11151);const a={title:"Best Practices",sidebar_label:"Best Practices",sidebar_position:13,slug:"/ibc/best-practices"},c="Best practices",o={id:"ibc/best-practices",title:"Best Practices",description:"Identifying legitimate channels",source:"@site/docs/01-ibc/13-best-practices.md",sourceDirName:"01-ibc",slug:"/ibc/best-practices",permalink:"/main/ibc/best-practices",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:13,frontMatter:{title:"Best Practices",sidebar_label:"Best Practices",sidebar_position:13,slug:"/ibc/best-practices"},sidebar:"defaultSidebar",previous:{title:"Capability Module",permalink:"/main/ibc/capability-module"},next:{title:"Permissioning",permalink:"/main/ibc/permissioning"}},r={},l=[{value:"Identifying legitimate channels",id:"identifying-legitimate-channels",level:2}];function h(e){const t={h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"best-practices",children:"Best practices"}),"\n",(0,n.jsx)(t.h2,{id:"identifying-legitimate-channels",children:"Identifying legitimate channels"}),"\n",(0,n.jsx)(t.p,{children:"Identifying which channel to use can be difficult as it requires verifying information about the chains you want to connect to.\nChannels are based on a light client. A chain can be uniquely identified by its chain ID, validator set pairing. It is unsafe to rely only on the chain ID.\nAny user can create a client with any chain ID, but only the chain with correct validator set and chain ID can produce headers which would update that client."}),"\n",(0,n.jsx)(t.p,{children:"Which channel to use is based on social consensus. The desired channel should have the following properties:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"based on a valid client (can only be updated by the chain it connects to)"}),"\n",(0,n.jsx)(t.li,{children:"has sizable activity"}),"\n",(0,n.jsx)(t.li,{children:"the underlying client is active"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"To verify if a client is valid. You will need to obtain a header from the chain you want to connect to. This can be done by running a full node for that chain or relying on a trusted rpc address.\nThen you should query the light client you want to verify and obtain its latest consensus state. All consensus state fields must match the header queried for at same height as the consensus state (root, timestamp, next validator set hash)."}),"\n",(0,n.jsx)(t.p,{children:"Explorers and wallets are highly encouraged to follow this practice. It is unsafe to algorithmically add new channels without following this process."})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},11151:(e,t,i)=>{i.d(t,{Z:()=>o,a:()=>c});var n=i(67294);const s={},a=n.createContext(s);function c(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);